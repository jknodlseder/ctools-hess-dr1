#! /usr/bin/env python
# ==========================================================================
# Display lightcurve generated by cslightcrv
#
# Copyright (C) 2019 Juergen Knoedlseder
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
# ==========================================================================
import sys
import gammalib
import cscripts
import matplotlib.pyplot as plt


# =================== #
# Get HESS lightcurve #
# =================== #
def get_hess_lightcurve(filename='pks-hess-data.csv'):
    """
    Get HESS lightcurve

    Parameters
    ----------
    filename : str, optional
        Light curve data file name

    Returns
    -------
    x, y, y_err : tuple of floats
        Energy, flux and flux error
    """
    # Open data file
    file1 = gammalib.GFilename('$CTAGITROOT/analysis/hess_dr1/%s' % filename)
    file2 = gammalib.GFilename('%s' % filename)
    if file1.exists():
        csv = gammalib.GCsv(file1,'\t')
    else:
        csv = gammalib.GCsv(file2,'\t')

    # Initialise arrays
    x     = []
    y     = []
    y_err = []

    # Loop over data
    for row in range(csv.nrows()):
        x.append(float(csv[row,0])+1.0/(24.0*60.0))
        y.append(float(csv[row,1])*1.0e-9)
        y_err.append((float(csv[row,2])-float(csv[row,1]))*1.0e-9)

    # Return
    return x,y,y_err


# =================== #
# Get HESS lightcurve #
# =================== #
def get_hess_lightcurve2(filename='pks-hess-data2.csv'):
    """
    Get HESS lightcurve

    Parameters
    ----------
    filename : str, optional
        Light curve data file name

    Returns
    -------
    x, y, y_err : tuple of floats
        Energy, flux and flux error
    """
    # Open data file
    file1 = gammalib.GFilename('$CTAGITROOT/analysis/hess_dr1/%s' % filename)
    file2 = gammalib.GFilename('%s' % filename)
    if file1.exists():
        csv = gammalib.GCsv(file1,' ')
    else:
        csv = gammalib.GCsv(file2,' ')

    # Initialise arrays
    x         = []
    y         = []
    y_err_min = []
    y_err_max = []

    # Loop over data
    for row in range(csv.nrows()):
        x.append(float(csv[row,0])-53900.0+1.0/(24.0*60.0))
        y.append(float(csv[row,2]))
        y_err_min.append(float(csv[row,3]))
        y_err_max.append(float(csv[row,4]))

    # Return
    return x,y,[y_err_min,y_err_max]


# =============== #
# Plot lightcurve #
# =============== #
def plot_lightcurve(filename, label='ctools (On/Off - wstat)'):
    """
    Plot lightcurve

    Parameters
    ----------
    filename : str
        Name of lightcurve FITS file
    label : str, optional
        Label
    """
    # Read spectrum file    
    fits    = gammalib.GFits(filename)
    table   = fits.table(1)
    
    # Extract standard columns
    c_mjd   = table['MJD']
    c_emjd  = table['e_MJD']
    c_ts    = table['TS']

    # Extract columns dependent on flux type
    if table.contains('EnergyFlux'):
        c_flux  = table['EnergyFlux']
        c_eflux = table['e_EnergyFlux']
        c_upper = table['EFluxUpperLimit']
        ylabel  = r'E $\times$ dN/dE (erg cm$^{-2}$ s$^{-1}$)'
    elif table.contains('PhotonFlux'):
        c_flux  = table['PhotonFlux']
        c_eflux = table['e_PhotonFlux']
        c_upper = table['FluxUpperLimit']
        ylabel  = r'Flux(>700 GeV) (ph cm$^{-2}$ s$^{-1}$)'
    else:
        c_flux  = table['Prefactor']
        c_eflux = table['e_Prefactor']
        c_upper = table['DiffUpperLimit']
        ylabel  = r'dN/dE (cm$^{-2}$ s$^{-1}$ MeV$^{-1}$)'

    # Initialise arrays to be filled
    mjd       = []
    e_mjd     = []
    flux      = []
    e_flux    = []
    ul_mjd    = []
    ul_e_mjd  = []
    ul_flux   = []
    ul_e_flux = []

    # Loop over rows of the file
    nrows = table.nrows()
    for row in range(nrows):

        # Get Test Statistic, flux and flux error
        ts    = c_ts.real(row)
        flx   = c_flux.real(row)
        e_flx = c_eflux.real(row)

        #

        # If Test Statistic is larger than 9 and twice the flux error is
        # smaller than the flux, then append flux point ...
        if ts > 0.0 and e_flx > 0.0:
            mjd.append(c_mjd.real(row)-53900.0)
            e_mjd.append(c_emjd.real(row))
            flux.append(c_flux.real(row))
            e_flux.append(c_eflux.real(row))

        # ... otherwise append upper limit
        else:
            #if c_upper.real(row) > 0.6e-10:
            #    continue
            ul_mjd.append(c_mjd.real(row)-53900.0)
            ul_e_mjd.append(c_emjd.real(row))
            ul_flux.append(c_upper.real(row))
            ul_e_flux.append(0.5*c_upper.real(row))

    # Get H.E.S.S. lightcurve
    #hess_x, hess_y, hess_y_err = get_hess_lightcurve()
    hess_x, hess_y, hess_y_err = get_hess_lightcurve2()

    # Create figure
    fig = plt.figure('Lightcurve', (12, 4))
    fig.subplots_adjust(left=0.07, right=0.98, top=0.94, bottom=0.14)
    ax = plt.subplot()
    ax.set_xlabel('MJD - 53900 (days)', fontsize=14)
    ax.set_ylabel(ylabel, fontsize=14)
    ax.set_xlim([45.835, 46.18])
    ax.set_ylim([-0.2e-10, 3.4e-10])
    for tick in ax.xaxis.get_major_ticks():
        tick.label.set_fontsize(14)
    for tick in ax.yaxis.get_major_ticks():
        tick.label.set_fontsize(14)
    ax.xaxis.set_ticks_position('both')
    ax.yaxis.set_ticks_position('both')
    ax.grid()

    # Plot the light curve 
    plt.errorbar(hess_x, hess_y, yerr=hess_y_err,
                 fmt='bo', label='Aharonian et al. (2009)')
    plt.errorbar(mjd, flux, yerr=e_flux, xerr=[e_mjd, e_mjd],
                 fmt='ro', label=label)
    plt.errorbar(ul_mjd, ul_flux, xerr=[ul_e_mjd, ul_e_mjd],
                 yerr=ul_e_flux, uplims=True, fmt='ro', label='_nolegend_')

    # Resort labels
    handles, labels = ax.get_legend_handles_labels()
    order           = [1,0]

    # Add legend
    ax.legend([handles[idx] for idx in order],[labels[idx] for idx in order])

    # Show figure
    plt.show()
    if '_3D' in filename:
        fig.savefig('pks_lightcrv_unbinned.png',dpi=300)
    else:
        fig.savefig('pks_lightcrv_onoff.png',dpi=300)

    # Return
    return


# ======================== #
# Main routine entry point #
# ======================== #
if __name__ == '__main__':

    # Plot 3D lightcurve
    plot_lightcurve('pks_lightcrv_ptsrc_fplaw700_lookup_grad_hess_edisp_3D.fits',
                    label='ctools (Unbinned)')

    # Plot OnOff lightcurve
    plot_lightcurve('pks_lightcrv_ptsrc_fplaw700_lookup_grad_hess_edisp_ONOFF_10bins.fits',
                     label='ctools (On/Off - wstat)')
